///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Copyright (C) 2020 HanvonUgee Technology Corp. All rights reserved.
//FileName: gd32f3x0_it.c
//Brief: main interrupt service routines
//Platform:GD32F350xxx
//Ver: V1.0.0
//Date:2020.07.16
//Author: Liming
//Modify: Felix_wang
//	1.ÕûÀí´úÂë
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "gd32f3x0_it.h"
#include "usbd_int.h"
#include "usb_delay.h"
#include "systick.h"

extern usb_core_handle_struct usbhs_core_dev;
extern uint32_t usbfs_prescaler;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles NMI exception
//    \param[in]  none
//    \param[out] none
//    \retval     none  
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NMI_Handler(void)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles HardFault exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void HardFault_Handler(void)
{
	// if Hard Fault exception occurs, go to infinite loop
	while (1);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles MemManage exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void MemManage_Handler(void)
{
	// if Memory Manage exception occurs, go to infinite loop
	while (1);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles BusFault exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void BusFault_Handler(void)
{
	//if Bus Fault exception occurs, go to infinite loop 
	while (1);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles UsageFault exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UsageFault_Handler(void)
{
	// if Usage Fault exception occurs, go to infinite loop 
	while (1);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles SVC exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SVC_Handler(void)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles DebugMon exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void DebugMon_Handler(void)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles PendSV exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void PendSV_Handler(void)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles SysTick exception
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SysTick_Handler(void)
{
	delay_decrement();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    \brief      this function handles USBD interrupt
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void  USBFS_IRQHandler (void)
{
	usbd_isr (&usbhs_core_dev);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles EXTI0_IRQ Handler
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles USBD wakeup interrupt request.
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void USBFS_WKUP_IRQHandler(void)
{
	if (usbhs_core_dev.cfg.low_power) 
	{
		SystemInit();

#ifndef USE_IRC48M
		rcu_ck48m_clock_config(RCU_CK48MSRC_PLL48M);

		rcu_usbfs_clock_config(usbfs_prescaler);
#else
		// enable IRC48M clock 
		rcu_osci_on(RCU_IRC48M);

		// wait till IRC48M is ready
		while (SUCCESS != rcu_osci_stab_wait(RCU_IRC48M)) ;

		rcu_ck48m_clock_config(RCU_CK48MSRC_IRC48M);
#endif

		rcu_periph_clock_enable(RCU_USBFS);

		usb_clock_ungate(&usbhs_core_dev);
	}

	exti_interrupt_flag_clear(EXTI_18);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    \brief      this function handles Timer14 updata interrupt request.
//    \param[in]  none
//    \param[out] none
//    \retval     none
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TIMER0_BRK_UP_TRG_COM_IRQHandler(void)
{
	timer_delay_irq();
}




